// Code generated by protoc-gen-go. DO NOT EDIT.
// source: eckv.proto

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	eckv.proto

It has these top-level messages:
	ProposalNum
	PaxosLog
	PaxosState
	Command
	GetReq
	GetResp
	PutReq
	PutResp
	CASReq
	CVASReq
	CASResp
	PrepareReq
	PrepareResp
	AcceptReq
	AcceptResp
	LearnReq
	LearnResp
	LogReq
	LogResp
	GCReq
	GCResp
*/
package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Command_CType int32

const (
	Command_PUT      Command_CType = 0
	Command_CPUT_VER Command_CType = 1
	Command_CPUT_VAL Command_CType = 2
)

var Command_CType_name = map[int32]string{
	0: "PUT",
	1: "CPUT_VER",
	2: "CPUT_VAL",
}
var Command_CType_value = map[string]int32{
	"PUT":      0,
	"CPUT_VER": 1,
	"CPUT_VAL": 2,
}

func (x Command_CType) String() string {
	return proto.EnumName(Command_CType_name, int32(x))
}
func (Command_CType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

type ProposalNum struct {
	Num  int64  `protobuf:"varint,1,opt,name=num" json:"num,omitempty"`
	DcId uint64 `protobuf:"fixed64,2,opt,name=dc_id,json=dcId" json:"dc_id,omitempty"`
}

func (m *ProposalNum) Reset()                    { *m = ProposalNum{} }
func (m *ProposalNum) String() string            { return proto.CompactTextString(m) }
func (*ProposalNum) ProtoMessage()               {}
func (*ProposalNum) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ProposalNum) GetNum() int64 {
	if m != nil {
		return m.Num
	}
	return 0
}

func (m *ProposalNum) GetDcId() uint64 {
	if m != nil {
		return m.DcId
	}
	return 0
}

type PaxosLog struct {
	Versions []*PaxosState `protobuf:"bytes,1,rep,name=versions" json:"versions,omitempty"`
	MinVer   int64         `protobuf:"varint,2,opt,name=min_ver,json=minVer" json:"min_ver,omitempty"`
	MaxVer   int64         `protobuf:"varint,3,opt,name=max_ver,json=maxVer" json:"max_ver,omitempty"`
}

func (m *PaxosLog) Reset()                    { *m = PaxosLog{} }
func (m *PaxosLog) String() string            { return proto.CompactTextString(m) }
func (*PaxosLog) ProtoMessage()               {}
func (*PaxosLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *PaxosLog) GetVersions() []*PaxosState {
	if m != nil {
		return m.Versions
	}
	return nil
}

func (m *PaxosLog) GetMinVer() int64 {
	if m != nil {
		return m.MinVer
	}
	return 0
}

func (m *PaxosLog) GetMaxVer() int64 {
	if m != nil {
		return m.MaxVer
	}
	return 0
}

type PaxosState struct {
	Ver             int64        `protobuf:"varint,1,opt,name=ver" json:"ver,omitempty"`
	HighestPropNum  *ProposalNum `protobuf:"bytes,2,opt,name=highest_prop_num,json=highestPropNum" json:"highest_prop_num,omitempty"`
	AcceptedPropNum *ProposalNum `protobuf:"bytes,3,opt,name=accepted_prop_num,json=acceptedPropNum" json:"accepted_prop_num,omitempty"`
	AcceptedValId   []byte       `protobuf:"bytes,4,opt,name=accepted_val_id,json=acceptedValId,proto3" json:"accepted_val_id,omitempty"`
	AcceptedValLen  int64        `protobuf:"varint,5,opt,name=accepted_val_len,json=acceptedValLen" json:"accepted_val_len,omitempty"`
	AcceptedChunks  [][]byte     `protobuf:"bytes,6,rep,name=accepted_chunks,json=acceptedChunks,proto3" json:"accepted_chunks,omitempty"`
	Chosen          bool         `protobuf:"varint,7,opt,name=chosen" json:"chosen,omitempty"`
}

func (m *PaxosState) Reset()                    { *m = PaxosState{} }
func (m *PaxosState) String() string            { return proto.CompactTextString(m) }
func (*PaxosState) ProtoMessage()               {}
func (*PaxosState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *PaxosState) GetVer() int64 {
	if m != nil {
		return m.Ver
	}
	return 0
}

func (m *PaxosState) GetHighestPropNum() *ProposalNum {
	if m != nil {
		return m.HighestPropNum
	}
	return nil
}

func (m *PaxosState) GetAcceptedPropNum() *ProposalNum {
	if m != nil {
		return m.AcceptedPropNum
	}
	return nil
}

func (m *PaxosState) GetAcceptedValId() []byte {
	if m != nil {
		return m.AcceptedValId
	}
	return nil
}

func (m *PaxosState) GetAcceptedValLen() int64 {
	if m != nil {
		return m.AcceptedValLen
	}
	return 0
}

func (m *PaxosState) GetAcceptedChunks() [][]byte {
	if m != nil {
		return m.AcceptedChunks
	}
	return nil
}

func (m *PaxosState) GetChosen() bool {
	if m != nil {
		return m.Chosen
	}
	return false
}

type Command struct {
	Cmd               Command_CType `protobuf:"varint,1,opt,name=cmd,enum=eckv.Command_CType" json:"cmd,omitempty"`
	Data              []byte        `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	PreviousVersion   int64         `protobuf:"varint,3,opt,name=previous_version,json=previousVersion" json:"previous_version,omitempty"`
	PreviousValueHash []byte        `protobuf:"bytes,4,opt,name=previous_value_hash,json=previousValueHash,proto3" json:"previous_value_hash,omitempty"`
}

func (m *Command) Reset()                    { *m = Command{} }
func (m *Command) String() string            { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()               {}
func (*Command) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Command) GetCmd() Command_CType {
	if m != nil {
		return m.Cmd
	}
	return Command_PUT
}

func (m *Command) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Command) GetPreviousVersion() int64 {
	if m != nil {
		return m.PreviousVersion
	}
	return 0
}

func (m *Command) GetPreviousValueHash() []byte {
	if m != nil {
		return m.PreviousValueHash
	}
	return nil
}

type GetReq struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
}

func (m *GetReq) Reset()                    { *m = GetReq{} }
func (m *GetReq) String() string            { return proto.CompactTextString(m) }
func (*GetReq) ProtoMessage()               {}
func (*GetReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *GetReq) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type GetResp struct {
	Val []byte `protobuf:"bytes,2,opt,name=val,proto3" json:"val,omitempty"`
	Ver string `protobuf:"bytes,3,opt,name=ver" json:"ver,omitempty"`
}

func (m *GetResp) Reset()                    { *m = GetResp{} }
func (m *GetResp) String() string            { return proto.CompactTextString(m) }
func (*GetResp) ProtoMessage()               {}
func (*GetResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *GetResp) GetVal() []byte {
	if m != nil {
		return m.Val
	}
	return nil
}

func (m *GetResp) GetVer() string {
	if m != nil {
		return m.Ver
	}
	return ""
}

type PutReq struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Val []byte `protobuf:"bytes,2,opt,name=val,proto3" json:"val,omitempty"`
}

func (m *PutReq) Reset()                    { *m = PutReq{} }
func (m *PutReq) String() string            { return proto.CompactTextString(m) }
func (*PutReq) ProtoMessage()               {}
func (*PutReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *PutReq) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *PutReq) GetVal() []byte {
	if m != nil {
		return m.Val
	}
	return nil
}

type PutResp struct {
	Ver string `protobuf:"bytes,1,opt,name=ver" json:"ver,omitempty"`
}

func (m *PutResp) Reset()                    { *m = PutResp{} }
func (m *PutResp) String() string            { return proto.CompactTextString(m) }
func (*PutResp) ProtoMessage()               {}
func (*PutResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *PutResp) GetVer() string {
	if m != nil {
		return m.Ver
	}
	return ""
}

type CASReq struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	New []byte `protobuf:"bytes,2,opt,name=new,proto3" json:"new,omitempty"`
	Old []byte `protobuf:"bytes,3,opt,name=old,proto3" json:"old,omitempty"`
}

func (m *CASReq) Reset()                    { *m = CASReq{} }
func (m *CASReq) String() string            { return proto.CompactTextString(m) }
func (*CASReq) ProtoMessage()               {}
func (*CASReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *CASReq) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *CASReq) GetNew() []byte {
	if m != nil {
		return m.New
	}
	return nil
}

func (m *CASReq) GetOld() []byte {
	if m != nil {
		return m.Old
	}
	return nil
}

type CVASReq struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	New []byte `protobuf:"bytes,2,opt,name=new,proto3" json:"new,omitempty"`
	Ver string `protobuf:"bytes,3,opt,name=ver" json:"ver,omitempty"`
}

func (m *CVASReq) Reset()                    { *m = CVASReq{} }
func (m *CVASReq) String() string            { return proto.CompactTextString(m) }
func (*CVASReq) ProtoMessage()               {}
func (*CVASReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *CVASReq) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *CVASReq) GetNew() []byte {
	if m != nil {
		return m.New
	}
	return nil
}

func (m *CVASReq) GetVer() string {
	if m != nil {
		return m.Ver
	}
	return ""
}

type CASResp struct {
	Success bool   `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
	Ver     string `protobuf:"bytes,2,opt,name=ver" json:"ver,omitempty"`
}

func (m *CASResp) Reset()                    { *m = CASResp{} }
func (m *CASResp) String() string            { return proto.CompactTextString(m) }
func (*CASResp) ProtoMessage()               {}
func (*CASResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *CASResp) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *CASResp) GetVer() string {
	if m != nil {
		return m.Ver
	}
	return ""
}

type PrepareReq struct {
	Key     string       `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Ver     int64        `protobuf:"varint,2,opt,name=ver" json:"ver,omitempty"`
	PropNum *ProposalNum `protobuf:"bytes,3,opt,name=prop_num,json=propNum" json:"prop_num,omitempty"`
}

func (m *PrepareReq) Reset()                    { *m = PrepareReq{} }
func (m *PrepareReq) String() string            { return proto.CompactTextString(m) }
func (*PrepareReq) ProtoMessage()               {}
func (*PrepareReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *PrepareReq) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *PrepareReq) GetVer() int64 {
	if m != nil {
		return m.Ver
	}
	return 0
}

func (m *PrepareReq) GetPropNum() *ProposalNum {
	if m != nil {
		return m.PropNum
	}
	return nil
}

type PrepareResp struct {
	Success bool `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
	// promise args
	AcceptedPropNum *ProposalNum `protobuf:"bytes,2,opt,name=accepted_prop_num,json=acceptedPropNum" json:"accepted_prop_num,omitempty"`
	AcceptedValId   []byte       `protobuf:"bytes,3,opt,name=accepted_val_id,json=acceptedValId,proto3" json:"accepted_val_id,omitempty"`
	AcceptedValLen  int64        `protobuf:"varint,4,opt,name=accepted_val_len,json=acceptedValLen" json:"accepted_val_len,omitempty"`
	AcceptedChunks  [][]byte     `protobuf:"bytes,5,rep,name=accepted_chunks,json=acceptedChunks,proto3" json:"accepted_chunks,omitempty"`
	// failed args
	HighestPropNum *ProposalNum `protobuf:"bytes,6,opt,name=highest_prop_num,json=highestPropNum" json:"highest_prop_num,omitempty"`
	DidGc          bool         `protobuf:"varint,7,opt,name=did_gc,json=didGc" json:"did_gc,omitempty"`
}

func (m *PrepareResp) Reset()                    { *m = PrepareResp{} }
func (m *PrepareResp) String() string            { return proto.CompactTextString(m) }
func (*PrepareResp) ProtoMessage()               {}
func (*PrepareResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *PrepareResp) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *PrepareResp) GetAcceptedPropNum() *ProposalNum {
	if m != nil {
		return m.AcceptedPropNum
	}
	return nil
}

func (m *PrepareResp) GetAcceptedValId() []byte {
	if m != nil {
		return m.AcceptedValId
	}
	return nil
}

func (m *PrepareResp) GetAcceptedValLen() int64 {
	if m != nil {
		return m.AcceptedValLen
	}
	return 0
}

func (m *PrepareResp) GetAcceptedChunks() [][]byte {
	if m != nil {
		return m.AcceptedChunks
	}
	return nil
}

func (m *PrepareResp) GetHighestPropNum() *ProposalNum {
	if m != nil {
		return m.HighestPropNum
	}
	return nil
}

func (m *PrepareResp) GetDidGc() bool {
	if m != nil {
		return m.DidGc
	}
	return false
}

type AcceptReq struct {
	Key     string       `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Ver     int64        `protobuf:"varint,2,opt,name=ver" json:"ver,omitempty"`
	PropNum *ProposalNum `protobuf:"bytes,3,opt,name=prop_num,json=propNum" json:"prop_num,omitempty"`
	ValId   []byte       `protobuf:"bytes,4,opt,name=val_id,json=valId,proto3" json:"val_id,omitempty"`
	ValLen  int64        `protobuf:"varint,5,opt,name=val_len,json=valLen" json:"val_len,omitempty"`
	Chunks  [][]byte     `protobuf:"bytes,6,rep,name=chunks,proto3" json:"chunks,omitempty"`
	SendLog bool         `protobuf:"varint,7,opt,name=send_log,json=sendLog" json:"send_log,omitempty"`
}

func (m *AcceptReq) Reset()                    { *m = AcceptReq{} }
func (m *AcceptReq) String() string            { return proto.CompactTextString(m) }
func (*AcceptReq) ProtoMessage()               {}
func (*AcceptReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *AcceptReq) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *AcceptReq) GetVer() int64 {
	if m != nil {
		return m.Ver
	}
	return 0
}

func (m *AcceptReq) GetPropNum() *ProposalNum {
	if m != nil {
		return m.PropNum
	}
	return nil
}

func (m *AcceptReq) GetValId() []byte {
	if m != nil {
		return m.ValId
	}
	return nil
}

func (m *AcceptReq) GetValLen() int64 {
	if m != nil {
		return m.ValLen
	}
	return 0
}

func (m *AcceptReq) GetChunks() [][]byte {
	if m != nil {
		return m.Chunks
	}
	return nil
}

func (m *AcceptReq) GetSendLog() bool {
	if m != nil {
		return m.SendLog
	}
	return false
}

type AcceptResp struct {
	Success         bool         `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
	AcceptedPropNum *ProposalNum `protobuf:"bytes,2,opt,name=accepted_prop_num,json=acceptedPropNum" json:"accepted_prop_num,omitempty"`
	Log             *PaxosLog    `protobuf:"bytes,3,opt,name=log" json:"log,omitempty"`
	// failed args
	HighestPropNum *ProposalNum `protobuf:"bytes,4,opt,name=highest_prop_num,json=highestPropNum" json:"highest_prop_num,omitempty"`
	DidGc          bool         `protobuf:"varint,5,opt,name=did_gc,json=didGc" json:"did_gc,omitempty"`
}

func (m *AcceptResp) Reset()                    { *m = AcceptResp{} }
func (m *AcceptResp) String() string            { return proto.CompactTextString(m) }
func (*AcceptResp) ProtoMessage()               {}
func (*AcceptResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *AcceptResp) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *AcceptResp) GetAcceptedPropNum() *ProposalNum {
	if m != nil {
		return m.AcceptedPropNum
	}
	return nil
}

func (m *AcceptResp) GetLog() *PaxosLog {
	if m != nil {
		return m.Log
	}
	return nil
}

func (m *AcceptResp) GetHighestPropNum() *ProposalNum {
	if m != nil {
		return m.HighestPropNum
	}
	return nil
}

func (m *AcceptResp) GetDidGc() bool {
	if m != nil {
		return m.DidGc
	}
	return false
}

type LearnReq struct {
	Key    string   `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Ver    int64    `protobuf:"varint,2,opt,name=ver" json:"ver,omitempty"`
	ValId  []byte   `protobuf:"bytes,3,opt,name=val_id,json=valId,proto3" json:"val_id,omitempty"`
	ValLen int64    `protobuf:"varint,4,opt,name=val_len,json=valLen" json:"val_len,omitempty"`
	Chunks [][]byte `protobuf:"bytes,5,rep,name=chunks,proto3" json:"chunks,omitempty"`
}

func (m *LearnReq) Reset()                    { *m = LearnReq{} }
func (m *LearnReq) String() string            { return proto.CompactTextString(m) }
func (*LearnReq) ProtoMessage()               {}
func (*LearnReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *LearnReq) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *LearnReq) GetVer() int64 {
	if m != nil {
		return m.Ver
	}
	return 0
}

func (m *LearnReq) GetValId() []byte {
	if m != nil {
		return m.ValId
	}
	return nil
}

func (m *LearnReq) GetValLen() int64 {
	if m != nil {
		return m.ValLen
	}
	return 0
}

func (m *LearnReq) GetChunks() [][]byte {
	if m != nil {
		return m.Chunks
	}
	return nil
}

type LearnResp struct {
}

func (m *LearnResp) Reset()                    { *m = LearnResp{} }
func (m *LearnResp) String() string            { return proto.CompactTextString(m) }
func (*LearnResp) ProtoMessage()               {}
func (*LearnResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

type LogReq struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
}

func (m *LogReq) Reset()                    { *m = LogReq{} }
func (m *LogReq) String() string            { return proto.CompactTextString(m) }
func (*LogReq) ProtoMessage()               {}
func (*LogReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *LogReq) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type LogResp struct {
	Log *PaxosLog `protobuf:"bytes,1,opt,name=log" json:"log,omitempty"`
}

func (m *LogResp) Reset()                    { *m = LogResp{} }
func (m *LogResp) String() string            { return proto.CompactTextString(m) }
func (*LogResp) ProtoMessage()               {}
func (*LogResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *LogResp) GetLog() *PaxosLog {
	if m != nil {
		return m.Log
	}
	return nil
}

type GCReq struct {
	Key        string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	MinKeepVer int64  `protobuf:"varint,2,opt,name=min_keep_ver,json=minKeepVer" json:"min_keep_ver,omitempty"`
}

func (m *GCReq) Reset()                    { *m = GCReq{} }
func (m *GCReq) String() string            { return proto.CompactTextString(m) }
func (*GCReq) ProtoMessage()               {}
func (*GCReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *GCReq) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *GCReq) GetMinKeepVer() int64 {
	if m != nil {
		return m.MinKeepVer
	}
	return 0
}

type GCResp struct {
}

func (m *GCResp) Reset()                    { *m = GCResp{} }
func (m *GCResp) String() string            { return proto.CompactTextString(m) }
func (*GCResp) ProtoMessage()               {}
func (*GCResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func init() {
	proto.RegisterType((*ProposalNum)(nil), "eckv.ProposalNum")
	proto.RegisterType((*PaxosLog)(nil), "eckv.PaxosLog")
	proto.RegisterType((*PaxosState)(nil), "eckv.PaxosState")
	proto.RegisterType((*Command)(nil), "eckv.Command")
	proto.RegisterType((*GetReq)(nil), "eckv.GetReq")
	proto.RegisterType((*GetResp)(nil), "eckv.GetResp")
	proto.RegisterType((*PutReq)(nil), "eckv.PutReq")
	proto.RegisterType((*PutResp)(nil), "eckv.PutResp")
	proto.RegisterType((*CASReq)(nil), "eckv.CASReq")
	proto.RegisterType((*CVASReq)(nil), "eckv.CVASReq")
	proto.RegisterType((*CASResp)(nil), "eckv.CASResp")
	proto.RegisterType((*PrepareReq)(nil), "eckv.PrepareReq")
	proto.RegisterType((*PrepareResp)(nil), "eckv.PrepareResp")
	proto.RegisterType((*AcceptReq)(nil), "eckv.AcceptReq")
	proto.RegisterType((*AcceptResp)(nil), "eckv.AcceptResp")
	proto.RegisterType((*LearnReq)(nil), "eckv.LearnReq")
	proto.RegisterType((*LearnResp)(nil), "eckv.LearnResp")
	proto.RegisterType((*LogReq)(nil), "eckv.LogReq")
	proto.RegisterType((*LogResp)(nil), "eckv.LogResp")
	proto.RegisterType((*GCReq)(nil), "eckv.GCReq")
	proto.RegisterType((*GCResp)(nil), "eckv.GCResp")
	proto.RegisterEnum("eckv.Command_CType", Command_CType_name, Command_CType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ECKV service

type ECKVClient interface {
	Get(ctx context.Context, in *GetReq, opts ...grpc.CallOption) (*GetResp, error)
	Put(ctx context.Context, in *PutReq, opts ...grpc.CallOption) (*PutResp, error)
	CAS(ctx context.Context, in *CASReq, opts ...grpc.CallOption) (*CASResp, error)
	CVAS(ctx context.Context, in *CVASReq, opts ...grpc.CallOption) (*CASResp, error)
}

type eCKVClient struct {
	cc *grpc.ClientConn
}

func NewECKVClient(cc *grpc.ClientConn) ECKVClient {
	return &eCKVClient{cc}
}

func (c *eCKVClient) Get(ctx context.Context, in *GetReq, opts ...grpc.CallOption) (*GetResp, error) {
	out := new(GetResp)
	err := grpc.Invoke(ctx, "/eckv.ECKV/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eCKVClient) Put(ctx context.Context, in *PutReq, opts ...grpc.CallOption) (*PutResp, error) {
	out := new(PutResp)
	err := grpc.Invoke(ctx, "/eckv.ECKV/Put", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eCKVClient) CAS(ctx context.Context, in *CASReq, opts ...grpc.CallOption) (*CASResp, error) {
	out := new(CASResp)
	err := grpc.Invoke(ctx, "/eckv.ECKV/CAS", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eCKVClient) CVAS(ctx context.Context, in *CVASReq, opts ...grpc.CallOption) (*CASResp, error) {
	out := new(CASResp)
	err := grpc.Invoke(ctx, "/eckv.ECKV/CVAS", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ECKV service

type ECKVServer interface {
	Get(context.Context, *GetReq) (*GetResp, error)
	Put(context.Context, *PutReq) (*PutResp, error)
	CAS(context.Context, *CASReq) (*CASResp, error)
	CVAS(context.Context, *CVASReq) (*CASResp, error)
}

func RegisterECKVServer(s *grpc.Server, srv ECKVServer) {
	s.RegisterService(&_ECKV_serviceDesc, srv)
}

func _ECKV_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ECKVServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eckv.ECKV/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ECKVServer).Get(ctx, req.(*GetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ECKV_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ECKVServer).Put(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eckv.ECKV/Put",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ECKVServer).Put(ctx, req.(*PutReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ECKV_CAS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CASReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ECKVServer).CAS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eckv.ECKV/CAS",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ECKVServer).CAS(ctx, req.(*CASReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ECKV_CVAS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CVASReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ECKVServer).CVAS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eckv.ECKV/CVAS",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ECKVServer).CVAS(ctx, req.(*CVASReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _ECKV_serviceDesc = grpc.ServiceDesc{
	ServiceName: "eckv.ECKV",
	HandlerType: (*ECKVServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _ECKV_Get_Handler,
		},
		{
			MethodName: "Put",
			Handler:    _ECKV_Put_Handler,
		},
		{
			MethodName: "CAS",
			Handler:    _ECKV_CAS_Handler,
		},
		{
			MethodName: "CVAS",
			Handler:    _ECKV_CVAS_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "eckv.proto",
}

// Client API for RSPaxos service

type RSPaxosClient interface {
	Prepare(ctx context.Context, in *PrepareReq, opts ...grpc.CallOption) (*PrepareResp, error)
	Accept(ctx context.Context, in *AcceptReq, opts ...grpc.CallOption) (*AcceptResp, error)
	Learn(ctx context.Context, in *LearnReq, opts ...grpc.CallOption) (*LearnResp, error)
	Log(ctx context.Context, in *LogReq, opts ...grpc.CallOption) (*LogResp, error)
	GC(ctx context.Context, in *GCReq, opts ...grpc.CallOption) (*GCResp, error)
}

type rSPaxosClient struct {
	cc *grpc.ClientConn
}

func NewRSPaxosClient(cc *grpc.ClientConn) RSPaxosClient {
	return &rSPaxosClient{cc}
}

func (c *rSPaxosClient) Prepare(ctx context.Context, in *PrepareReq, opts ...grpc.CallOption) (*PrepareResp, error) {
	out := new(PrepareResp)
	err := grpc.Invoke(ctx, "/eckv.RSPaxos/Prepare", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rSPaxosClient) Accept(ctx context.Context, in *AcceptReq, opts ...grpc.CallOption) (*AcceptResp, error) {
	out := new(AcceptResp)
	err := grpc.Invoke(ctx, "/eckv.RSPaxos/Accept", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rSPaxosClient) Learn(ctx context.Context, in *LearnReq, opts ...grpc.CallOption) (*LearnResp, error) {
	out := new(LearnResp)
	err := grpc.Invoke(ctx, "/eckv.RSPaxos/Learn", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rSPaxosClient) Log(ctx context.Context, in *LogReq, opts ...grpc.CallOption) (*LogResp, error) {
	out := new(LogResp)
	err := grpc.Invoke(ctx, "/eckv.RSPaxos/Log", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rSPaxosClient) GC(ctx context.Context, in *GCReq, opts ...grpc.CallOption) (*GCResp, error) {
	out := new(GCResp)
	err := grpc.Invoke(ctx, "/eckv.RSPaxos/GC", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RSPaxos service

type RSPaxosServer interface {
	Prepare(context.Context, *PrepareReq) (*PrepareResp, error)
	Accept(context.Context, *AcceptReq) (*AcceptResp, error)
	Learn(context.Context, *LearnReq) (*LearnResp, error)
	Log(context.Context, *LogReq) (*LogResp, error)
	GC(context.Context, *GCReq) (*GCResp, error)
}

func RegisterRSPaxosServer(s *grpc.Server, srv RSPaxosServer) {
	s.RegisterService(&_RSPaxos_serviceDesc, srv)
}

func _RSPaxos_Prepare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RSPaxosServer).Prepare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eckv.RSPaxos/Prepare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RSPaxosServer).Prepare(ctx, req.(*PrepareReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RSPaxos_Accept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RSPaxosServer).Accept(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eckv.RSPaxos/Accept",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RSPaxosServer).Accept(ctx, req.(*AcceptReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RSPaxos_Learn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LearnReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RSPaxosServer).Learn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eckv.RSPaxos/Learn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RSPaxosServer).Learn(ctx, req.(*LearnReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RSPaxos_Log_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RSPaxosServer).Log(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eckv.RSPaxos/Log",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RSPaxosServer).Log(ctx, req.(*LogReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RSPaxos_GC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GCReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RSPaxosServer).GC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eckv.RSPaxos/GC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RSPaxosServer).GC(ctx, req.(*GCReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _RSPaxos_serviceDesc = grpc.ServiceDesc{
	ServiceName: "eckv.RSPaxos",
	HandlerType: (*RSPaxosServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Prepare",
			Handler:    _RSPaxos_Prepare_Handler,
		},
		{
			MethodName: "Accept",
			Handler:    _RSPaxos_Accept_Handler,
		},
		{
			MethodName: "Learn",
			Handler:    _RSPaxos_Learn_Handler,
		},
		{
			MethodName: "Log",
			Handler:    _RSPaxos_Log_Handler,
		},
		{
			MethodName: "GC",
			Handler:    _RSPaxos_GC_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "eckv.proto",
}

func init() { proto.RegisterFile("eckv.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 947 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xdd, 0x8e, 0xdb, 0x44,
	0x14, 0x5e, 0xc7, 0xbf, 0x7b, 0x92, 0xee, 0x7a, 0x67, 0x05, 0x0d, 0xe1, 0x26, 0x8c, 0xa0, 0x04,
	0xd8, 0xae, 0x50, 0x80, 0xab, 0x0a, 0xd0, 0x62, 0x55, 0xa1, 0x6a, 0x84, 0x22, 0xef, 0x36, 0x17,
	0x5c, 0x60, 0x4d, 0xed, 0x51, 0x62, 0x36, 0xb1, 0x07, 0x4f, 0xe2, 0x6e, 0xdf, 0x86, 0x17, 0xe0,
	0x92, 0x7b, 0x5e, 0x80, 0x27, 0xe0, 0x82, 0x57, 0x41, 0x33, 0x9e, 0x89, 0x93, 0xe2, 0x40, 0xaa,
	0xaa, 0x77, 0x33, 0xe7, 0x7c, 0x73, 0xce, 0x7c, 0xe7, 0xcc, 0xf9, 0x6c, 0x00, 0x1a, 0xdf, 0x96,
	0x97, 0xac, 0xc8, 0x57, 0x39, 0xb2, 0xc4, 0x1a, 0x7f, 0x09, 0xed, 0x49, 0x91, 0xb3, 0x9c, 0x93,
	0xc5, 0x0f, 0xeb, 0x25, 0xf2, 0xc1, 0xcc, 0xd6, 0xcb, 0xae, 0xd1, 0x37, 0x06, 0x66, 0x28, 0x96,
	0xe8, 0x1c, 0xec, 0x24, 0x8e, 0xd2, 0xa4, 0xdb, 0xea, 0x1b, 0x03, 0x27, 0xb4, 0x92, 0xf8, 0x49,
	0x82, 0x7f, 0x06, 0x6f, 0x42, 0xee, 0x72, 0x3e, 0xce, 0x67, 0xe8, 0x02, 0xbc, 0x92, 0x16, 0x3c,
	0xcd, 0x33, 0xde, 0x35, 0xfa, 0xe6, 0xa0, 0x3d, 0xf4, 0x2f, 0x65, 0x1a, 0x89, 0xb8, 0x5e, 0x91,
	0x15, 0x0d, 0x37, 0x08, 0x74, 0x1f, 0xdc, 0x65, 0x9a, 0x45, 0x25, 0x2d, 0x64, 0x40, 0x33, 0x74,
	0x96, 0x69, 0x36, 0xa5, 0x85, 0x74, 0x90, 0x3b, 0xe9, 0x30, 0x95, 0x83, 0xdc, 0x4d, 0x69, 0x81,
	0x7f, 0x6b, 0x01, 0xd4, 0xa1, 0xc4, 0x0d, 0x05, 0x46, 0xdd, 0xb0, 0xa4, 0x05, 0x7a, 0x04, 0xfe,
	0x3c, 0x9d, 0xcd, 0x29, 0x5f, 0x45, 0xac, 0xc8, 0x59, 0x24, 0x08, 0x88, 0xd8, 0xed, 0xe1, 0x99,
	0xba, 0x48, 0x4d, 0x30, 0x3c, 0x51, 0x50, 0x61, 0x13, 0x84, 0xbf, 0x86, 0x33, 0x12, 0xc7, 0x94,
	0xad, 0x68, 0x52, 0x9f, 0x36, 0xf7, 0x9d, 0x3e, 0xd5, 0x58, 0x7d, 0xfc, 0x01, 0x6c, 0x4c, 0x51,
	0x49, 0x16, 0xa2, 0x4e, 0x56, 0xdf, 0x18, 0x74, 0xc2, 0x7b, 0xda, 0x3c, 0x25, 0x8b, 0x27, 0x09,
	0x1a, 0x80, 0xbf, 0x83, 0x5b, 0xd0, 0xac, 0x6b, 0x4b, 0x0a, 0x27, 0x5b, 0xc0, 0x31, 0xcd, 0xd0,
	0xc7, 0x5b, 0x11, 0xe3, 0xf9, 0x3a, 0xbb, 0xe5, 0x5d, 0xa7, 0x6f, 0x0e, 0x3a, 0x35, 0x30, 0x90,
	0x56, 0xf4, 0x2e, 0x38, 0xf1, 0x3c, 0xe7, 0x34, 0xeb, 0xba, 0x7d, 0x63, 0xe0, 0x85, 0x6a, 0x87,
	0xff, 0x34, 0xc0, 0x0d, 0xf2, 0xe5, 0x92, 0x64, 0x09, 0xfa, 0x08, 0xcc, 0x78, 0x99, 0xc8, 0x62,
	0x9d, 0x0c, 0xcf, 0x2b, 0x3e, 0xca, 0x77, 0x19, 0xdc, 0xbc, 0x64, 0x34, 0x14, 0x7e, 0x84, 0xc0,
	0x4a, 0xc8, 0x8a, 0xc8, 0xaa, 0x75, 0x42, 0xb9, 0x46, 0x9f, 0x80, 0xcf, 0x0a, 0x5a, 0xa6, 0xf9,
	0x9a, 0x47, 0xaa, 0x7b, 0xaa, 0x31, 0xa7, 0xda, 0x3e, 0xad, 0xcc, 0xe8, 0x12, 0xce, 0x6b, 0x28,
	0x59, 0xac, 0x69, 0x34, 0x27, 0x7c, 0xae, 0x0a, 0x71, 0xb6, 0x41, 0x0b, 0xcf, 0xf7, 0x84, 0xcf,
	0xf1, 0x05, 0xd8, 0x32, 0x39, 0x72, 0xc1, 0x9c, 0x3c, 0xbb, 0xf1, 0x8f, 0x50, 0x07, 0xbc, 0x60,
	0xf2, 0xec, 0x26, 0x9a, 0x3e, 0x0e, 0x7d, 0xa3, 0xde, 0x5d, 0x8d, 0xfd, 0x16, 0xee, 0x81, 0x33,
	0xa2, 0xab, 0x90, 0xfe, 0x22, 0x5a, 0x7f, 0x4b, 0x5f, 0x4a, 0x36, 0xc7, 0xa1, 0x58, 0xe2, 0x87,
	0xe0, 0x4a, 0x1f, 0x67, 0xf2, 0x5d, 0x90, 0x85, 0xa2, 0x20, 0x96, 0xfa, 0xa5, 0x98, 0x15, 0xbc,
	0xa4, 0x05, 0xbe, 0x00, 0x67, 0xb2, 0x6e, 0x0e, 0xf5, 0xef, 0xf3, 0xf8, 0x7d, 0x70, 0x25, 0x5a,
	0x05, 0x57, 0x8f, 0x4e, 0x85, 0xfa, 0x06, 0x9c, 0xe0, 0xea, 0x7a, 0x6f, 0xa8, 0x8c, 0xbe, 0xd0,
	0xa1, 0x32, 0xfa, 0x42, 0x58, 0xf2, 0x45, 0x22, 0xaf, 0xd2, 0x09, 0xc5, 0x12, 0x7f, 0x0b, 0x6e,
	0x30, 0x7d, 0xad, 0x00, 0xaf, 0x70, 0xf9, 0x0a, 0x5c, 0x79, 0x01, 0xce, 0x50, 0x17, 0x5c, 0xbe,
	0x8e, 0x63, 0xca, 0xb9, 0x0c, 0xe2, 0x85, 0x7a, 0xab, 0x8f, 0xb5, 0xea, 0x63, 0x3f, 0x01, 0x4c,
	0x0a, 0xca, 0x48, 0x41, 0xf7, 0x97, 0x61, 0x33, 0x9b, 0x72, 0xbc, 0x2e, 0xc0, 0xfb, 0xff, 0xc1,
	0x70, 0x59, 0x35, 0x10, 0xf8, 0xf7, 0x96, 0x10, 0x14, 0x95, 0xe0, 0x3f, 0xef, 0xd6, 0x38, 0x79,
	0xad, 0x37, 0x99, 0x3c, 0xf3, 0xd0, 0xc9, 0xb3, 0x0e, 0x9d, 0x3c, 0xbb, 0x71, 0xf2, 0x9a, 0x04,
	0xc7, 0x39, 0x54, 0x70, 0xde, 0x01, 0x27, 0x49, 0x93, 0x68, 0x16, 0xab, 0xb1, 0xb5, 0x93, 0x34,
	0x19, 0xc5, 0xf8, 0x0f, 0x03, 0x8e, 0xaf, 0x64, 0x9a, 0xb7, 0xd2, 0x17, 0x91, 0x76, 0x47, 0x9f,
	0xec, 0x52, 0x56, 0xe7, 0x3e, 0xb8, 0xbb, 0x72, 0x24, 0x50, 0xa2, 0x18, 0x52, 0x5d, 0xb6, 0xd4,
	0x47, 0xed, 0xd0, 0x7b, 0xe0, 0x71, 0x9a, 0x25, 0xd1, 0x22, 0x9f, 0x29, 0x02, 0xae, 0xd8, 0x8f,
	0xf3, 0x19, 0xfe, 0xcb, 0x00, 0xd0, 0x14, 0xde, 0x66, 0xe7, 0xfb, 0x60, 0x8a, 0xec, 0x15, 0xe7,
	0x93, 0xad, 0x6f, 0xcd, 0x38, 0x9f, 0x85, 0xc2, 0xd5, 0xd8, 0x20, 0xeb, 0xf5, 0x1b, 0x64, 0x6f,
	0x37, 0xa8, 0x04, 0x6f, 0x4c, 0x49, 0x91, 0x1d, 0xda, 0x9e, 0xba, 0xe0, 0xe6, 0x9e, 0x82, 0x5b,
	0x7b, 0x0a, 0x6e, 0x6f, 0x17, 0x1c, 0xb7, 0xe1, 0x58, 0xe5, 0xe5, 0x4c, 0x68, 0xa1, 0x20, 0xd9,
	0xa8, 0x85, 0x9f, 0x81, 0x2b, 0x7d, 0x9c, 0xe9, 0x0a, 0x19, 0x7b, 0x2b, 0x84, 0x1f, 0x81, 0x3d,
	0x0a, 0x9a, 0xa9, 0xf4, 0xa1, 0x23, 0xbe, 0xd0, 0xb7, 0x94, 0xb2, 0xad, 0xcf, 0x34, 0x2c, 0xd3,
	0xec, 0x29, 0xa5, 0x4c, 0x7c, 0x91, 0x3d, 0x70, 0xc4, 0x61, 0xce, 0x86, 0xbf, 0x1a, 0x60, 0x3d,
	0x0e, 0x9e, 0x4e, 0xd1, 0x87, 0x60, 0x8e, 0xe8, 0x0a, 0x75, 0xaa, 0x5c, 0x95, 0x5e, 0xf7, 0xee,
	0x6d, 0xed, 0x38, 0xc3, 0x47, 0x02, 0x35, 0x59, 0x6f, 0x50, 0x95, 0x14, 0x6b, 0x94, 0x92, 0xda,
	0x0a, 0x15, 0x5c, 0x5d, 0x6b, 0x54, 0xa5, 0xb2, 0x1a, 0xa5, 0x24, 0x0f, 0x1f, 0xa1, 0x07, 0x60,
	0x09, 0x01, 0x45, 0xda, 0x31, 0x6d, 0xc6, 0x0d, 0xff, 0x36, 0xc0, 0x0d, 0xaf, 0x25, 0x7b, 0xf4,
	0x39, 0xb8, 0x4a, 0x9b, 0x90, 0xfe, 0x47, 0xd9, 0x68, 0x61, 0xef, 0xec, 0x15, 0x8b, 0xcc, 0xf2,
	0x10, 0x9c, 0xea, 0x49, 0xa3, 0xd3, 0xca, 0xbd, 0x99, 0xd1, 0x9e, 0xbf, 0x6b, 0x90, 0xf0, 0x4f,
	0xc1, 0x96, 0xcd, 0x42, 0xaa, 0xe8, 0xfa, 0xc5, 0xf4, 0x4e, 0x77, 0xf6, 0x9a, 0xa6, 0xf8, 0x7d,
	0x52, 0x34, 0xab, 0xb6, 0xea, 0xeb, 0xab, 0x46, 0xe2, 0x23, 0xf4, 0x01, 0xb4, 0x46, 0x01, 0x6a,
	0xab, 0x4a, 0x8a, 0x96, 0xf5, 0x3a, 0xf5, 0x46, 0x40, 0xbe, 0xb3, 0x7e, 0x6c, 0xb1, 0xe7, 0xcf,
	0x1d, 0xf9, 0x57, 0xf7, 0xc5, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xa7, 0xb3, 0xa7, 0x66, 0xe3,
	0x09, 0x00, 0x00,
}
